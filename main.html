<!DOCTYPE html>
<html>
<head>
  <title>Игра с движением, разворотом модели, столкновениями и стрелой</title>
  <style>
    #gameCanvas {
      border: 1px solid #000;
    }

    #hpBar {
      width: 200px;
      height: 20px;
      background-color: #f00;
      margin: 10px;
    }

    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 40px;
      color: red;
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <div id="hpBar"></div>
  <div id="gameOver">Game Over</div>

  <script>
    // Получение ссылки на холст
    var canvas = document.getElementById("gameCanvas");
    var context = canvas.getContext("2d");

    // Создание объектов изображений модели
    var playerImages = {
      up: new Image(),
      down: new Image(),
      left: new Image(),
      right: new Image()
    };

    // Загрузка изображений модели
    playerImages.up.src = "up.png"; // Замените "bin/up.png" на путь к изображению модели, смотрящей вверх
    playerImages.down.src = "down.png"; // Замените "bin/down.png" на путь к изображению модели, смотрящей вниз
    playerImages.left.src = "left.png"; // Замените "bin/left.png" на путь к изображению модели, смотрящей влево
    playerImages.right.src = "right.png"; // Замените "bin/right.png" на путь к изображению модели, смотрящей вправо

    // Начальные координаты и направление игрока
    var playerX = canvas.width / 2;
    var playerY = canvas.height / 2;
    var playerWidth = 50;
    var playerHeight = 50;
    var playerSpeed = 5;
    var playerDirection = "down"; // Начальное направление взгляда модели

    // Массив для хранения текущих нажатых клавиш
    var keys = {};

    // Обработка нажатия и отпускания клавиш
    document.addEventListener("keydown", function(event) {
      keys[event.key] = true;
    });

    document.addEventListener("keyup", function(event) {
      keys[event.key] = false;
    });

    // Определение стенок в игре
    var walls = [
      { x: 200, y: 100, width: 20, height: 200 }, // Пример стенки: x=200, y=100, width=20, height=200
      // Добавьте остальные стенки в игре по аналогии
    ];

    // Переменная для хранения значения здоровья (ХП)
    var health = 100;

    // Переменные для стрелы
    var arrowX, arrowY, arrowWidth, arrowHeight, arrowSpeed, arrowDirection;

    // Переменные для отображения надписи "Game Over"
    var gameOverText = document.getElementById("gameOver");
    var isGameOver = false;

    // Функция для проверки столкновения игрока с каждой стенкой
    function checkCollisionWithWalls() {
      for (var i = 0; i < walls.length; i++) {
        var wall = walls[i];

        if (
          playerX < wall.x + wall.width &&
          playerX + playerWidth > wall.x &&
          playerY < wall.y + wall.height &&
          playerY + playerHeight > wall.y
        ) {
          // Игрок столкнулся со стенкой, выполняйте нужные действия
          // Например, остановите игрока или измените направление движения
        }
      }
    }

    // Функция для проверки столкновения стрелы с игроком
    function checkCollisionWithPlayer() {
      if (
        arrowX < playerX + playerWidth &&
        arrowX + arrowWidth > playerX &&
        arrowY < playerY + playerHeight &&
        arrowY + arrowHeight > playerY
      ) {
        // Стрела столкнулась с игроком
        gameOver();
      }
    }

    // Функция для отображения надписи "Game Over" и остановки игры
    function gameOver() {
      isGameOver = true;
      gameOverText.style.display = "block";
    }

    // Обновление игры и отрисовка игрока, стрелы
    function update() {
      if (isGameOver) {
        return;
      }

      // Проверка нажатых клавиш и изменение координат игрока
      if (keys["ArrowUp"]) {
        playerY -= playerSpeed;
        if (playerY < 0) {
          playerY = 0;
        }
        playerDirection = "up";
      }

      if (keys["ArrowDown"]) {
        playerY += playerSpeed;
        if (playerY > canvas.height - playerHeight) {
          playerY = canvas.height - playerHeight;
        }
        playerDirection = "down";
      }

      if (keys["ArrowLeft"]) {
        playerX -= playerSpeed;
        if (playerX < 0) {
          playerX = 0;
        }
        playerDirection = "left";
      }

      if (keys["ArrowRight"]) {
        playerX += playerSpeed;
        if (playerX > canvas.width - playerWidth) {
          playerX = canvas.width - playerWidth;
        }
        playerDirection = "right";
      }

      // Проверка столкновений с "стенками"
      checkCollisionWithWalls();

      // Генерация случайных координат и скорости стрелы
      if (!arrowX) {
        arrowX = Math.random() * (canvas.width - arrowWidth);
        arrowY = Math.random() * (canvas.height - arrowHeight);
        arrowWidth = 20;
        arrowHeight = 20;
        arrowSpeed = Math.random() * 3 + 1; // Случайная скорость от 1 до 4
        arrowDirection = Math.random() * 2 * Math.PI; // Случайное направление в радианах
      }

      // Обновление координат стрелы
      arrowX += arrowSpeed * Math.cos(arrowDirection);
      arrowY += arrowSpeed * Math.sin(arrowDirection);

      // Проверка столкновения стрелы с игроком
      checkCollisionWithPlayer();

      // Очистка холста
      context.clearRect(0, 0, canvas.width, canvas.height);

      // Отрисовка игрока в зависимости от направления взгляда
      switch (playerDirection) {
        case "up":
          context.drawImage(playerImages.up, playerX, playerY, playerWidth, playerHeight);
          break;
        case "down":
          context.drawImage(playerImages.down, playerX, playerY, playerWidth, playerHeight);
          break;
        case "left":
          context.drawImage(playerImages.left, playerX, playerY, playerWidth, playerHeight);
          break;
        case "right":
          context.drawImage(playerImages.right, playerX, playerY, playerWidth, playerHeight);
          break;
      }

      // Отрисовка стрелы
      context.fillStyle = "#000";
      context.fillRect(arrowX, arrowY, arrowWidth, arrowHeight);

      // Обновление полоски здоровья (ХП)
      var hpBar = document.getElementById("hpBar");
      hpBar.style.width = health + "px";

      // Повторный вызов функции обновления для создания анимации
      requestAnimationFrame(update);
    }

    // Запуск игры после загрузки изображений модели
    Promise.all([
      new Promise((resolve, reject) => {
        playerImages.up.onload = resolve;
      }),
      new Promise((resolve, reject) => {
        playerImages.down.onload = resolve;
      }),
      new Promise((resolve, reject) => {
        playerImages.left.onload = resolve;
      }),
      new Promise((resolve, reject) => {
        playerImages.right.onload = resolve;
      })
    ]).then(() => {
      update();
    });
  </script>
</body>
</html>